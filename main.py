import streamlit as st

import home, about, favorites, account
import mysql.connector
import toml
import bcrypt
from home import app, get_user_info
from dotenv import load_dotenv
import json
import requests

from streamlit_lottie import st_lottie
from streamlit_lottie import st_lottie_spinner

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import random
import string
import time

st.set_page_config(
     page_title="hAin:AI Recipe Generator",
     page_icon= "üç¥",
 )


@st.cache_data
def load_lottiefile(filepath: str):
    with open(filepath, "r") as f:
        data = json.load(f)
    return data


def load_lottieurl(url: str):
    r = requests.get(url)
    if r.status_code != 200:
        return None
    return r.json()



def connect_to_database():
    secrets = toml.load("streamlit/secrets.toml")
    mysql_config = secrets["connections"]["mysql"]
        
    return mysql.connector.connect(
        host=mysql_config["host"],
        port=mysql_config["port"],
        user=mysql_config["user"],
        password=mysql_config["password"],
        database=mysql_config["database"]
    )


def create_user_table(conn):
    cursor = conn.cursor()
    try:
        cursor.execute("CREATE TABLE IF NOT EXISTS users (id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(255) NOT NULL, first_name VARCHAR(255) NOT NULL, last_name VARCHAR(255), email VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL)")
        conn.commit()
    except mysql.connector.Error as err:
        st.error(f"Error: {err}")
    finally:
        cursor.close()        



# Function to generate OTP

def generate_otp():
    # return str(random.randint(100000, 999999))
    otp = ''.join(random.choices(string.digits, k=6))  # Generates a 6-digit OTP
    generate_otp.__code__ = (lambda: None).__code__  # Deactivates the function
    return otp

# Function to send OTP via email
def send_otp(email, otp):
    sender_email = "wahabiz.wayofwahab@gmail.com"  # Replace with your email
    sender_password = "vrgp olkm kfjb rwuv"        # Replace with your email password

    
    subject = "OTP for Signup Verification"
    body = f"Your OTP for signup verification is: {otp}"
    
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = email
    message['Subject'] = subject
    message.attach(MIMEText(body, 'plain'))
    
    with smtplib.SMTP('smtp.gmail.com', 587) as server:
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, email, message.as_string())


def get_session_state():
    # Check if session state is already initialized
    if 'session_state' not in st.session_state:
        # Initialize session state
        st.session_state.session_state = {}
    return st.session_state.session_state

def validate_otp(entered_otp, expected_otp):
    """
    Function to validate the entered OTP.
    
    Parameters:
        entered_otp (str): The OTP entered by the user.
        expected_otp (str): The expected OTP generated by the system.
    
    Returns:
        bool: True if the entered OTP matches the expected OTP, False otherwise.
    """
    return entered_otp == expected_otp


class MultiApp:
    def __init__(self):
        pass

    def run(self):
        if not hasattr(st.session_state, 'logged_in'):
            st.session_state.logged_in = False

        if not st.session_state.logged_in:
            
            tab1, tab2 = st.tabs(['Login', 'Sign Up'])
            with tab1:
                self.login()
            with tab2:
                self.signup()    

        if st.session_state.logged_in:
            self.main()


    def login(self):
        with st.container(height=None, border=True):
            username = st.text_input("Username")     
            password = st.text_input("Password", type="password", key="password_login")

            if st.button('Login'):
                conn = connect_to_database()
                try:
                    cursor = conn.cursor()
                    query = "SELECT * FROM users WHERE username = %s"
                    cursor.execute(query, (username,))
                    user = cursor.fetchone()
                    
                    if user:
                        user_id = user[0]
                        username = user[1]
                        first_name = user[2]
                        last_name = user[3]
                        email = user[4]
                        # Verify hashed password
                        hashed_password = user[5]
                        if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):
                            user_dict = {
                                "id": user[0],
                                "username": user[1],
                                "first_name": user[2],
                                "email": user[4] 
                            }                           
                            st.success("Login successful!")
                            st.session_state.logged_in  = True
                            st.session_state.user_id    = user_id
                            st.session_state.username   = username
                            st.session_state.first_name = first_name
                            st.session_state.last_name  = last_name
                            st.session_state.email      = email
                            
                            st.rerun()
                            # user_id = get_user_id(query)

                        else:
                            st.error("Invalid username or password.")
                    else:
                        st.error("Invalid username or password.")
                except mysql.connector.Error as err:
                    st.error(f"Error: {err}")
                finally:
                    if 'cursor' in locals():
                        cursor.close()
                    if conn.is_connected():
                        conn.close()
                        
            # Return None if login fails
            return None, False


    def signup(self):

        with st.container(height=None, border=True):
            username = st.text_input('Username', key="username_signup")
            col1, col2 = st.columns(2)
            with col1:
                first_name = st.text_input('First Name' , key="firstname")
            with col2:                   
                last_name = st.text_input('Last Name', key="lastname") 

            col1, col2 = st.columns([4,1])
            with col1:           
                email = st.text_input('Email Address' , key="emailaddress")

            otp = None    
            with col2:
                session_state = get_session_state()
                try:
                    # Retrieve the previous state of the send OTP checkbox
                    send_otp_button = session_state.get("send_otp_button", False)
                    otp_sent_timestamps = session_state.get("otp_sent_timestamps", {})

                    # # Checkbox for sending OTP
                    # send_otp_button = st.checkbox("Send OTP", value=send_otp_button)

                    # # Update session state with the current state of the send OTP checkbox
                    # session_state["send_otp_button"] = send_otp_button

                    # If send OTP button is checked
                    # if send_otp_button:
                    #     if email:
                    #         # Check if OTP was already sent to this user within a certain time frame
                    #         if email in otp_sent_timestamps:
                    #             # Assuming you want to resend OTP only after 5 minutes
                    #             # if time.time() - otp_sent_timestamps[email] >= 300:  # 300 seconds = 5 minutes
                    #             if time.time() - otp_sent_timestamps[email]["timestamp"] >= 300:  # 300 seconds = 5 minutes
                    #                 otp = generate_otp()
                    #                 st.write("My OTP:", otp)
                    #                 send_otp(email, otp)
                    #                 st.success("OTP sent successfully. After 5 min")
                    #                 # otp_sent_timestamps[email] = time.time()  # Update timestamp
                    #                 otp_sent_timestamps[email] = {"otp": otp, "timestamp": time.time()}  # Update timestamp and OTP
                    #                 print("OTP sent timestamp updated.")
                    #             else:
                    #                 st.error("OTP already sent within the last 5 minutes.")
                    #         else:
                    #             otp = generate_otp()
                    #             send_otp(email, otp)
                    #             st.success("OTP sent successfully. First Time")
                    #             # otp_sent_timestamps[email] = time.time()  # Store timestamp
                    #             otp_sent_timestamps[email] = {"otp": otp, "timestamp": time.time()}  # Store timestamp and OTP
                    #             print("OTP sent timestamp added.")
                    #     else:
                    #         st.error("Enter Your Email")
                    # # Update session state with the current state of the OTP timestamps
                    # session_state["otp_sent_timestamps"] = otp_sent_timestamps

                except Exception as e:
                    st.error(f"An error occurred: {e}")

            expected_otp = None
            try:
                pass
                # # Get the last timestamp from the dictionary
                # otp_values = [data["otp"] for data in otp_sent_timestamps.values()]
                # expected_otp = max(otp_values) if otp_values else None            
                # # expected_otp = max(otp_sent_timestamps.values()) if otp_sent_timestamps else None
                # entered_otp = st.text_input('Enter Your OTP:' , key="otp")
            except:
                pass

            password  = st.text_input('Password', type='password', key="password")
            


            if st.button('Sign Up'):


                # if validate_otp(entered_otp, expected_otp):
                conn = connect_to_database()
                try:
                    cursor = conn.cursor()
                    cursor.execute("SHOW TABLES LIKE 'users'")
                    table_exists = cursor.fetchone()
                    if not table_exists:
                        create_user_table(conn)  # Create the users table if it doesn't exist  
                    # Check if username already exists
                    cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
                    if cursor.fetchone():
                        st.error("Username already exists. Please choose a different one.")
                        return
                    # Check if email already exists
                    cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
                    if cursor.fetchone():
                        st.error("Email address already exists. Please use a different one.")
                        return
                    # Hash the password before inserting it into the database
                    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

                    query = "INSERT INTO users (username, first_name, last_name, email, password) VALUES (%s, %s, %s, %s, %s)"
                    cursor.execute(query, (username, first_name, last_name,  email, hashed_password.decode('utf-8')))  # Decode hashed password before inserting

                    conn.commit()
                    st.success('Signup Successful')
                except mysql.connector.Error as err:
                    st.error(f"Error: {err}")
                finally:
                    if 'cursor' in locals():
                        cursor.close()
                    if conn.is_connected(): 
                        conn.close()
                # else:
                #     st.error("Invalid OTP") 


    def main(self):
        conn = connect_to_database()

        st.markdown("""
        <style>
            [data-testid=stSidebar] {
                background-color: #FFF8F4;
            }
        </style>
        """, unsafe_allow_html=True)
        with st.sidebar:
                st.image("./Animations/hain2.png", 
                        #caption="Your PNG caption",
                        width=200)
                        #align="center")                

        #st.sidebar.title("hAin")           
        st.sidebar.markdown("<hr>", unsafe_allow_html=True)
        
        first_name = st.session_state.first_name
        # st.sidebar.subheader(f"Hello, {first_name}!")
        with st.sidebar.expander(label=first_name):
            if st.button('Logout'):
                st.session_state.logged_in = False
                st.rerun()
            


        st.sidebar.markdown("<hr>", unsafe_allow_html=True)
        

        icons = {
            "Home": "üè† Home",
            "Favorites": "‚ù§Ô∏è Favourites",
            "Account": "üë§ Account"
        }      
        
        app_selection = st.sidebar.radio("Select Page", ['Home', 'Favorites', 'Account'], format_func=lambda x: icons[x])


        # Display selected page
        if app_selection == "Home":
            home.app()
        elif app_selection == "Favorites":
            favorites.app()
        elif app_selection == 'Account':
            account.app()


        # Close database connection when finished
        if conn.is_connected():
            conn.close()


# Create MultiApp instance and run it
multi_app = MultiApp()
multi_app.run()